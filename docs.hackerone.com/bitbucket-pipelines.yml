URI, UUID, and structures
You should be familiar with REST architecture before writing an integration. Read this overview page to gain a good understanding of Bitbucket's REST implementation.
On this page

URI structure
HTTP methods
UUID
User object and UUID
Repository object and UUID
Team object and UUID
Standard error responses
Standard ISO-8601 timestamps
URI structure
All Bitbucket Cloud requests start with the https://api.bitbucket.org/2.0 prefix (for the 2.0 API) and https://api.bitbucket.org/1.0 prefix (1.0 API).
The next segment of the URI path depends on the endpoint of the request. For example, using the curl command and the repositories endpoint you can list all the issues on Bitbucket's tutorial repository:
curl https://api.bitbucket.org/2.0/repositories/tutorials/tutorials.bitbucket.org
Given a specific endpoint, you can then drill down to a particular aspect or resource of that endpoint. The issues resource on a repository is an example:
curl https://api.bitbucket.org/1.0/repositories/tutorials/tutorials.bitbucket.org/issues
HTTP methods
A given endpoint or resource has a series of actions (or methods) associated with it. The Bitbucket service supports these standard HTTP methods:
Call	Description
GET	Retrieves information.
PUT	Updates existing information.
POST	Creates new information.
DELETE	Removes existing information.
For example, you can call use the POST action on the issues resource and create an issue on the issue tracker.
Specifying content length

You can get a 411 Length Required response. If this happens, the API requires a Content-Length header but the client is not sending it. You should add the header yourself, for example using the curl client:
curl -r PUT --header "Content-Length: 0" -u user:pass https://api.bitbucket.org/1.0/emails/rap@atlassian.com
Universally Unique Identifier
UUID's provide a single point of recognition for users, teams, and repositories. The UUID is distinct from the username, team name, and repository name fields and remains the same even when those fields change. For example when a user changes their username or moves a repository you will need to modify calls which use those identifiers but not if you are pointing to the UUID.
UUID examples and structure
UUID's work with both the 1.0 and 2.0 APIs for the user, team, and repository objects. The following examples the following characters are replacements for curly brackets: %7B replaces { and %7D replaces }. You will see this structure in the following example sections.
User object and UUID
When you make a call using either the username or the UUID for that user the response is the same.
Call with username:
curl https://api.bitbucket.org/2.0/users/tutorials
*Call with UUID for the user:
curl https://api.bitbucket.org/2.0/users/%7Bc788b2da-b7a2-404c-9e26-d3f077557007%7D
Response

{
    "username": "tutorials",
    "nickname": "tutorials",
    "account_status": "active",
    "website": "https://tutorials.bitbucket.org/",
    "display_name": "tutorials account",
    "uuid": "{c788b2da-b7a2-404c-9e26-d3f077557007}",
    "links": {
        "self": {
            "href": "https://api.bitbucket.org/2.0/users/tutorials"
        },
        "repositories": {
            "href": "https://api.bitbucket.org/2.0/repositories/tutorials"
        },
        "html": {
            "href": "https://bitbucket.org/tutorials"
        },
        "followers": {
            "href": "https://api.bitbucket.org/2.0/users/tutorials/followers"
        },
        "avatar": {
            "href": "https://bitbucket-assetroot.s3.amazonaws.com/c/photos/2013/Nov/25/tutorials-avatar-1563784409-6_avatar.png"
        },
        "following": {
            "href": "https://api.bitbucket.org/2.0/users/tutorials/following"
        }
    },
    "created_on": "2011-12-20T16:34:07.132459+00:00",
    "location": "Santa Monica, CA",
    "type": "user"
}
Repository object and UUID
Once you have the UUID for a repository you no longer need a username or team name to make the API call so long as you use an empty field. This helps you resolve repositories no matter if the username or team name changes.
Call with team name (1team) and repository name (moxie):
curl https://api.bitbucket.org/2.0/repositories/1team/moxie
Call with UUID and empty field:
curl https://api.bitbucket.org/2.0/repositories/%7B%7D/%7B21fa9bf8-b5b2-4891-97ed-d590bad0f871%7D
Call with UUID and teamname:
curl https://api.bitbucket.org/2.0/repositories/1team/%7B21fa9bf8-b5b2-4891-97ed-d590bad0f871%7D
Response

{
    "created_on": "2013-11-08T01:11:03.222520+00:00",
    "description": "",
    "fork_policy": "allow_forks",
    "full_name": "1team/moxie",
    "has_issues": false,
    "has_wiki": false,
    "is_private": false,
    "language": "",
    "links": {
        "avatar": {
            "href": "https://bitbucket.org/1team/moxie/avatar/32/"
        },
        "branches": {
            "href": "https://api.bitbucket.org/2.0/repositories/1team/moxie/refs/branches"
        },
        "clone": [
            {
                "href": "https://bitbucket.org/1team/moxie.git",
                "name": "https"
            },
            {
                "href": "ssh://git@bitbucket.org/1team/moxie.git",
                "name": "ssh"
            }
        ],
        "commits": {
            "href": "https://api.bitbucket.org/2.0/repositories/1team/moxie/commits"
        },
        "downloads": {
            "href": "https://api.bitbucket.org/2.0/repositories/1team/moxie/downloads"
        },
        "forks": {
            "href": "https://api.bitbucket.org/2.0/repositories/1team/moxie/forks"
        },
        "hooks": {
            "href": "https://api.bitbucket.org/2.0/repositories/1team/moxie/hooks"
        },
        "html": {
            "href": "https://bitbucket.org/1team/moxie"
        },
        "pullrequests": {
            "href": "https://api.bitbucket.org/2.0/repositories/1team/moxie/pullrequests"
        },
        "self": {
            "href": "https://api.bitbucket.org/2.0/repositories/1team/moxie"
        },
        "tags": {
            "href": "https://api.bitbucket.org/2.0/repositories/1team/moxie/refs/tags"
        },
        "watchers": {
            "href": "https://api.bitbucket.org/2.0/repositories/1team/moxie/watchers"
        }
    },
    "name": "moxie",
    "owner": {
        "display_name": "the team",
        "links": {
            "avatar": {
                "href": "https://bitbucket.org/account/1team/avatar/32/"
            },
            "html": {
                "href": "https://bitbucket.org/1team/"
            },
            "self": {
                "href": "https://api.bitbucket.org/2.0/teams/1team"
            }
        },
        "type": "team",
        "username": "1team",
        "uuid": "{aa559944-83c9-4963-a9a8-69ac8d9cf5d2}"
    },
    "project": {
        "key": "PROJ",
        "links": {
            "avatar": {
                "href": "https://bitbucket.org/account/user/1team/projects/PROJ/avatar/32"
            },
            "html": {
                "href": "https://bitbucket.org/account/user/1team/projects/PROJ"
            }
        },
        "name": "Untitled project",
        "type": "project",
        "uuid": "{ab52aaeb-16ad-4fb0-bb1d-47e4f00367ff}"
    },
    "scm": "git",
    "size": 33348,
    "type": "repository",
    "updated_on": "2013-11-08T01:11:03.263237+00:00",
    "uuid": "{21fa9bf8-b5b2-4891-97ed-d590bad0f871}",
    "website": ""
}
Team object and UUID
This example shows a call for a list of team members using both the team name and with the UUID for the team object. As the call is unauthenticated in the following example the response object will only show members with public profiles. The response is the same in either case.
Call with teamname

curl https://api.bitbucket.org/2.0/teams/1team/members
Call with UUID for team object

curl https://api.bitbucket.org/2.0/teams/%7Baa559944-83c9-4963-a9a8-69ac8d9cf5d2%7D/members
Response

{
    "page": 1,
    "pagelen": 50,
    "size": 2,
    "values": [
        {
            "created_on": "2011-12-20T16:34:07.132459+00:00",
            "display_name": "tutorials account",
            "links": {
                "avatar": {
                    "href": "https://bitbucket.org/account/tutorials/avatar/32/"
                },
                "followers": {
                    "href": "https://api.bitbucket.org/2.0/users/tutorials/followers"
                },
                "following": {
                    "href": "https://api.bitbucket.org/2.0/users/tutorials/following"
                },
                "hooks": {
                    "href": "https://api.bitbucket.org/2.0/users/tutorials/hooks"
                },
                "html": {
                    "href": "https://bitbucket.org/tutorials/"
                },
                "repositories": {
                    "href": "https://api.bitbucket.org/2.0/repositories/tutorials"
                },
                "self": {
                    "href": "https://api.bitbucket.org/2.0/users/tutorials"
                },
                "snippets": {
                    "href": "https://api.bitbucket.org/2.0/snippets/tutorials"
                }
            },
            "location": null,
            "type": "user",
            "username": "tutorials",
            "nickname": "tutorials",
            "account_status": "active",
            "uuid": "{c788b2da-b7a2-404c-9e26-d3f077557007}",
            "website": "https://tutorials.bitbucket.org/"
        },
        {
            "created_on": "2013-12-10T14:44:13+00:00",
            "display_name": "Dan Stevens [Atlassian]",
            "links": {
                "avatar": {
                    "href": "https://bitbucket.org/account/dans9190/avatar/32/"
                },
                "followers": {
                    "href": "https://api.bitbucket.org/2.0/users/dans9190/followers"
                },
                "following": {
                    "href": "https://api.bitbucket.org/2.0/users/dans9190/following"
                },
                "hooks": {
                    "href": "https://api.bitbucket.org/2.0/users/dans9190/hooks"
                },
                "html": {
                    "href": "https://bitbucket.org/dans9190/"
                },
                "repositories": {
                    "href": "https://api.bitbucket.org/2.0/repositories/dans9190"
                },
                "self": {
                    "href": "https://api.bitbucket.org/2.0/users/dans9190"
                },
                "snippets": {
                    "href": "https://api.bitbucket.org/2.0/snippets/dans9190"
                }
            },
            "location": null,
            "type": "user",
            "username": "dans9190",
            "nickname": "dans9190",
            "account_status": "active",
            "uuid": "{1cd06601-cd0e-4fce-be03-e9ac226978b7}",
            "website": ""
        }
    ]
}
Standardized error responses
The 2.0 API standardizes the error response layout. The 2.0 API serves a JSON object along with the appropriate HTTP status code. The JSON object provides a detailed problem description.
{
    "type": "error",
    "error": {
        "message": "Bad request",
        "fields": {
            "src": [
                "This field is required."
            ]
        },
        "detail": "You must specify a valid source branch when creating a pull request.",
        "id": "d23a1cc5178f7637f3d9bf2d13824258",
        "data": {
          "extra": "Optional, endpoint-specific data to further augment the error."
        }
    }
}
This object contains an error element which contains the following nested elements:
Element	Description
message	A short description of the problem. This element is always present. Its value may be localized.
fields	This optional element is used in response to POST or PUT operations in which clients have provided invalid input. It contains a list of one or more client-provided fields that failed validation. The values may be localized.
detail	An optional detailed explanation of the failure. Its value may be localized.
id	An optional unique error identifier that identifies the error in Bitbucket's logging system. If you feel you hit a bug in an API and this field is provided, please mention it if you decide to contact support as it will greatly help us narrow down the problem.
Standard ISO-8601 timestamps
All 2.0 APIs use standardized ISO-8601 timestamps. In most cases, our APIs return UTC timestamps and for these, the timezone offset part will be 00:00. In rare cases where the original localized timestamp has significance, the timezone offset may identify the event's original timezone.
Cors and hypermedia
This section describes Cross-origin resource sharing (CORS), what content types we support in requests and responses, and hyperlinking resources in each json responses.
On this page

CORS
Supported content types
Resource links
Cors
The Bitbucket API supports Cross-origin resource sharing to allow requests for restricted resources across domains. For more information you can refer to:
Wikipedia article on CORS
W3C CORS recommendation
Sending a general request from the api to bitbucket.com:
curl -i https://api.bitbucket.org -H "origin: http://bitbucket.com"

Gives this result:
HTTP/1.1 302 FOUND
Server: nginx/1.6.2
Vary: Cookie
Cache-Control: max-age=900
Content-Type: text/html; charset=utf-8
Strict-Transport-Security: max-age=31536000
Date: Tue, 21 Jun 2016 17:54:37 GMT
Location: http://confluence.atlassian.com/x/IYBGDQ
X-Served-By: app-110
X-Static-Version: 2c820eb0d2b3
ETag: "d41d8cd98f00b204e9800998ecf8427e"
X-Content-Type-Options: nosniff
X-Render-Time: 0.00379920005798
Connection: Keep-Alive
X-Version: 2c820eb0d2b3
X-Frame-Options: SAMEORIGIN
X-Request-Count: 383
X-Cache-Info: cached
Content-Length: 0
Sending the same request with the CORS check -X OPTIONS in the call:
curl -i https://api.bitbucket.org -H "origin: http://bitbucket.com" -X OPTIONS

Gives this result:
HTTP/1.1 302 FOUND
Server: nginx/1.6.2
Vary: Cookie
Cache-Control: max-age=900
Content-Type: text/html; charset=utf-8
Access-Control-Expose-Headers: Accept-Ranges, Content-Encoding, Content-Length, Content-Type, ETag, Last-Modified
Strict-Transport-Security: max-age=31536000
Date: Tue, 21 Jun 2016 18:04:30 GMT
Access-Control-Max-Age: 86400
Location: http://confluence.atlassian.com/x/IYBGDQ
X-Served-By: app-111
Access-Control-Allow-Origin: *
X-Static-Version: 2c820eb0d2b3
ETag: "d41d8cd98f00b204e9800998ecf8427e"
X-Content-Type-Options: nosniff
X-Render-Time: 0.00371098518372
Connection: keep-alive
X-Version: 2c820eb0d2b3
X-Frame-Options: SAMEORIGIN
X-Request-Count: 357
Access-Control-Allow-Methods: GET, POST, PUT, PATCH, DELETE, OPTIONS
Access-Control-Allow-Headers: Accept, Authorization, Content-Type, If-Match, If-Modified-Since, If-None-Match, If-Unmodified-Since, Origin, Range, X-CsrftokenX-Requested-With
X-Cache-Info: not cacheable; request wasn't a GET or HEAD
Content-Length: 0
Supported content types
The default and primary content type for 2.0 APIs is JSON. This applies both to responses from the server and to the request bodies provided by the client.
Unless documented otherwise, whenever creating a new (POST) or modifying an existing (PUT) object, your client must provide the object's normal representation. Not every object element can be mutated. For example, a repository's created_on date is an auto-generated, immutable field. Your client can omit immutable fields from a request body.
In some cases, a resource might also accept regular application/x-www-url-form-encoded POST and PUT bodies. Such bodies can be more convenient in scripts and command line usage. Requests bodies can contain contain nested elements or they can be flat (without nested elements). Clients can send flat request bodies as either as application/json or as application/x-www-url-form-encoded. Nested objects always require JSON.
Resource links
Every 2.0 object contains a links element that points to related resources or alternate representations. Use links to quickly discover and traverse to related objects. Links serve a "self-documenting" function for each endpoint. For example, the following request for a specific user:
$ curl https://api.bitbucket.org/2.0/users/tutorials

{
    "username": "tutorials",
    "nickname": "tutorials",
    "account_status": "active",
    "website": "https://tutorials.bitbucket.org/",
    "display_name": "tutorials account",
    "uuid": "{c788b2da-b7a2-404c-9e26-d3f077557007}",
    "links": {
        "self": {
            "href": "https://api.bitbucket.org/2.0/users/tutorials"
        },
        "repositories": {
            "href": "https://api.bitbucket.org/2.0/repositories/tutorials"
        },
        "html": {
            "href": "https://bitbucket.org/tutorials"
        },
        "followers": {
            "href": "https://api.bitbucket.org/2.0/users/tutorials/followers"
        },
        "avatar": {
            "href": "https://bitbucket-assetroot.s3.amazonaws.com/c/photos/2013/Nov/25/tutorials-avatar-1563784409-6_avatar.png"
        },
        "following": {
            "href": "https://api.bitbucket.org/2.0/users/tutorials/following"
        }
    },
    "created_on": "2011-12-20T16:34:07.132459+00:00",
    "location": "Santa Monica, CA",
    "type": "user"
}
Links can be actual REST API resources or they can be informational. In this example, informative resources include the user's avatar and the HTML URL for the user's Bitbucket account. Your client should avoid hardcoding an API's URL and instead use the URLs returned in API responses.
A link's key is its rel (relationship) attribute and it contains a mandatory href element. For example, the following link:
"self": {
      "href": "https://api.bitbucket.org/api/2.0/users/tutorials"
}
The rel for this link is self and the href is https://api.bitbucket.org/api/2.0/users/tutorials. A single rel key can contain an list (array) of href objects. Your client should anticipate that any rel key can contain one or more href objects.
Finally, links can also contain optional elements. Two common optional elements are the name element and the title element. They are often used to disambiguate links that share the same rel key. In the example below, the repository object that contains a clone link with two href objects. Each object contains the optional name element to clarify its use.
"links": {
  "self": {
    "href": "https://api.bitbucket.org/2.0/repositories/evzijst/bitbucket"
  },
  "clone": [
    {
      "href": "https://api.bitbucket.org/evzijst/bitbucket.git",
      "name": "https"
    },
    {
      "href": "ssh://git@bitbucket.org/erik/bitbucket.git",
      "name": "ssh"
    }
  ],
  ...
}
Links can support URI Templates; Those that do contain a "templated": "true" element.
- pipe: atlassian/aws-elasticbeanstalk-deploy:0.6.0
  variables:
    AWS_ACCESS_KEY_ID: '<string>'
    AWS_SECRET_ACCESS_KEY: '<string>'
    AWS_DEFAULT_REGION: '<string>'
    APPLICATION_NAME: '<string>'
    ENVIRONMENT_NAME: '<string>'
    ZIP_FILE: '<string>'
    # S3_BUCKET: '<string>' # Optional.
    # VERSION_LABEL: '<string>' # Optional.
    # DESCRIPTION: '<string>' # Optional.
    # WAIT: '<boolean>' # Optional.
    # WAIT_INTERVAL: '<integer>' # Optional.
    # COMMAND: '<string>' # Optional.
    # DEBUG: '<boolean>' # Optional.
# Node.js
# Build a general Node.js project with npm.
# Add steps that analyze code, save build artifacts, deploy, and more:
# https://docs.microsoft.com/azure/devops/pipelines/languages/javascript

pool:
  vmImage: 'Ubuntu 16.04'

steps:
- task: NodeTool@0
  inputs:
    versionSpec: '8.x'
  displayName: 'Install Node.js'

- script: |
    npm install
    cd function-app/GanacheFunction
    npm install
  displayName: 'Install project dependencies'

- script: |
    npx truffle compile
    npx truffle test
  displayName: 'Truffle Compile & Test'

  # azure-pipelines.js - Publish Test Results in 
- task: PublishTestResults@2
  condition: always()
  inputs:
    testResultsFormat: 'JUnit'
    testResultsFiles: '**/TEST-*.xml' 

- task: ArchiveFiles@2
  inputs:
    rootFolderOrFile: '$(System.DefaultWorkingDirectory)'
    includeRootFolder: false
    archiveType: 'zip'
    archiveFile: '$(Build.ArtifactStagingDirectory)/full-$(Build.BuildId).zip'

- task: ArchiveFiles@2
  inputs:
    rootFolderOrFile: '$(System.DefaultWorkingDirectory)/function-app'
    includeRootFolder: false
    archiveType: 'zip'
    archiveFile: '$(Build.ArtifactStagingDirectory)/function-app-$(Build.BuildId).zip'

- task: PublishBuildArtifacts@1
  inputs:
    pathToPublish: '$(Build.ArtifactStagingDirectory)'
    Open API Specification
Bitbucket uses the Open API Specification (OAI, formerly known as Swagger) to describe its APIs. Our OAI specification schema is hosted at https://api.bitbucket.org/swagger.json and serves as the canonical definition and comprehensive declaration of all available endpoints.
The OAI specification makes writing client applications easier by: auto-generating boilerplate code (like data object classes) and dealing with authentication and error handling.
You can find a comprehensive set of open tools for the OAI specification at: https://github.com/swagger-api.
JSON Schema
Bitbucket uses JSON Schema to describe the layout of every type of object consumed or produced by the API. These schemas are collected under the #definitions element of our swagger.json file.
When an endpoint expects an object as part of a POST or PUT, it also expects the object to validate against the JSON schemas. The same applies to objects returned by an endpoint.
Condensed Versus Full Objects
Most objects in Bitbucket come both in "full" and "partial" representation. The full representation is when all elements are included. This is the layout returned by a resource's self location (e.g. /2.0/repositories/foo/bar), as well as resource collection endpoints (e.g. /2.0/repositories).
However, Bitbucket objects often embed other objects. For example, a repository object embeds a user object for its owner. Likewise, a pullrequest object embeds its repository object.
These related objects are embedded, or inlined, to reduce the "chatter" when clients make frequent followup API calls to collect information on common, related information.
Embedded related objects are typically limited in their fields to avoid such object graphs from becoming too deep and noisy. They often exclude their own nested objects in an attempt to strike a balance between performance and utility.
An object's embedded or condensed representation tends to be standardized, meaning the fields included is the same set, regardless of where the object was embedded.
